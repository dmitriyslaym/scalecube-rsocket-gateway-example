import { ReplaySubject, Observable, throwError } from 'rxjs';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

const assert = (predicate, msg) => {
    if (!predicate) {
        throw new Error(msg);
    }
};
const isDefined = (val) => typeof val !== 'undefined';
const assertDefined = (val, msg = 'Expect to be defined') => {
    assert(isDefined(val), msg);
};
const isString = (val) => typeof val === 'string' || val instanceof String;
const assertString = (val, msg = 'Expected to be a string') => {
    assert(isDefined(val) && isString(val), msg);
};
const assertNonEmptyString = (val, msg = 'Expected to be non empty string') => {
    assertString(val, msg);
    assert(val.length > 0, msg);
};
const isArray = (val) => Array.isArray(val);
const isNonEmptyArray = (val) => isArray(val) && val.length > 0;
const assertArray = (val, msg = 'Expected to be an array') => {
    assert(isArray(val), msg);
};
const asserNotEmptytArray = (val, msg = 'Expected to be an array') => {
    assert(isNonEmptyArray(val), msg);
};
const isObject = (val) => Object.prototype.toString.call(val) === '[object Object]';
const assertObject = (val, msg = 'Expected to be an object') => {
    assert(isObject(val), msg);
};
const assertNonEmptyObject = (val, msg = 'Expected to be non empty object') => {
    assertObject(val, msg);
    assert(Object.keys(val).length > 0, msg);
};
const isOneOf = (collection, val) => {
    if (isArray(collection)) {
        return collection.includes(val);
    }
    if (isObject(collection)) {
        return Object.values(collection).includes(val);
    }
    return false;
};
const assertOneOf = (collection, val, msg = 'Expected to be one of the collection elements') => {
    assert(isOneOf(collection, val), msg);
};
const isFunction = (val) => typeof val === 'function' && !/^class\s/.test(Function.prototype.toString.call(val));
const assertFunction = (val, msg = 'Expected to be a function') => {
    assert(isFunction(val), msg);
};
const isNumber = (val) => typeof val === 'number' && !isNaN(val);
const assertNumber = (val, msg = 'Expected to be a number') => {
    assert(isNumber(val), msg);
};

const NOT_VALID_PROTOCOL = 'Not a valid protocol';
const NOT_VALID_ADDRESS = 'Address must be of type object';
const NOT_VALID_HOST = 'Not a valid host';
const NOT_VALID_PATH = 'Not a valid path';
const NOT_VALID_PORT = 'Not a valid port';
const ASYNC_MODEL_TYPES = {
    REQUEST_RESPONSE: 'requestResponse',
    REQUEST_STREAM: 'requestStream',
};
const SERVICE_NAME_NOT_PROVIDED = 'MS0020 - Invalid format, definition must contain valid serviceName';
const DEFINITION_MISSING_METHODS = 'MS0021 - Invalid format, definition must contain valid methods';
const INVALID_METHODS = 'MS0022 - Invalid format, definition must contain valid methods';
const getServiceNameInvalid = (serviceName) => `MS0023 - Invalid format, serviceName must be not empty string but received type ${typeof serviceName}`;
const getIncorrectMethodValueError = (qualifier) => `Method value for ${qualifier} definition should be non empty object`;
const getAsynModelNotProvidedError = (qualifier) => `Async model is not provided in service definition for ${qualifier}`;
const getInvalidAsyncModelError = (qualifier) => `Invalid async model in service definition for ${qualifier}`;

const validateAddress = (address, isOptional = true) => {
    if (isOptional && typeof address === 'undefined') {
        return true;
    }
    assertNonEmptyObject(address, NOT_VALID_ADDRESS);
    const { host, path, protocol } = address;
    let { port } = address;
    port = isString(port) ? Number(port) : port;
    assertString(host, NOT_VALID_HOST);
    assertString(path, NOT_VALID_PATH);
    assertNumber(port, NOT_VALID_PORT);
    assertString(protocol, NOT_VALID_PROTOCOL);
    assert(isOneOf(['pm', 'ws', 'wss', 'tcp'], protocol), NOT_VALID_PROTOCOL);
    return true;
};
/**
 * address is <protocol>://<host>:<port>/<path>
 */
const getFullAddress = (address) => {
    validateAddress(address, false);
    const { host, path, port, protocol } = address;
    return `${protocol}://${host}:${port}/${path}`;
};
const getAddress = (address) => {
    const newAddress = {};
    address = buildAddress({ key: 'protocol', optionalValue: 'pm', delimiter: '://', str: address, newAddress });
    address = buildAddress({ key: 'host', optionalValue: 'defaultHost', delimiter: ':', str: address, newAddress });
    address = buildAddress({ key: 'port', optionalValue: 8080, delimiter: '/', str: address, newAddress });
    newAddress.path = address;
    return newAddress;
};
const buildAddress = ({ key, optionalValue, delimiter, newAddress, str, }) => {
    let [v1, rest] = str.split(delimiter);
    if (!rest) {
        rest = v1;
        v1 = optionalValue;
    }
    newAddress[key] = v1;
    return rest;
};

const isNodejs = () => {
    try {
        // common api for main threat or worker in the browser
        return !navigator;
    }
    catch (e) {
        return false;
    }
};

const workersMap = {};
const registeredIframes = {};
const iframes = [];
/**
 * check from which iframe the event arrived,
 * @param ev
 */
const registerIframe = (ev) => {
    iframes.some((iframe) => {
        if (ev.source === iframe.contentWindow) {
            registeredIframes[ev.data.detail.whoAmI || ev.data.detail.origin] = iframe;
        }
        return ev.source === iframe.contentWindow;
    });
};
const initialize = () => {
    if (!isNodejs()) {
        // @ts-ignore
        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
            console.warn(`Don't use this on webworkers, only on the main thread`);
        }
        else {
            addEventListener('message', (ev) => {
                if (ev && ev.data && !ev.data.workerId) {
                    ev.data.type === 'ConnectIframe' && registerIframe(ev);
                    const detail = ev.data.detail;
                    if (detail) {
                        ev.data.workerId = 1;
                        const propogateTo = workersMap[detail.to] || workersMap[detail.address]; // discoveryEvents || rsocketEvents
                        if (propogateTo) {
                            // @ts-ignore
                            propogateTo.postMessage(ev.data, ev.ports);
                        }
                        const iframe = registeredIframes[detail.to] || registeredIframes[detail.address];
                        if (iframe) {
                            iframe.contentWindow.postMessage(ev.data, '*', ev.ports);
                        }
                    }
                }
            });
        }
    }
};
function workerEventHandler(ev) {
    if (ev.data && ev.data.detail && ev.data.type) {
        const detail = ev.data.detail;
        if (!ev.data.workerId) {
            ev.data.workerId = 1;
            if (ev.data.type === 'ConnectWorkerEvent') {
                if (detail.whoAmI) {
                    // @ts-ignore
                    workersMap[detail.whoAmI] = this;
                }
            }
            else {
                const propogateTo = workersMap[detail.to] || workersMap[detail.address]; // discoveryEvents || rsocketEvents
                if (propogateTo) {
                    // @ts-ignore
                    propogateTo.postMessage(ev.data, ev.ports);
                }
                else {
                    // @ts-ignore
                    postMessage(ev.data, '*', ev.ports);
                }
            }
        }
    }
}
const addWorker = (worker) => {
    worker.addEventListener('message', workerEventHandler.bind(worker));
};
const removeWorker = (worker) => {
    worker.removeEventListener('message', workerEventHandler.bind(worker));
};
const addIframe = (iframe) => {
    iframes.push(iframe);
};

const colorsMap = {};
const getRandomColor = () => {
    const letters = '0123456789ABCDEF';
    let color = '#';
    for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
};
const saveToLogs = (identifier, msg, extra, debug, type = 'log') => {
    if (!colorsMap[identifier]) {
        colorsMap[identifier] = getRandomColor();
    }
    // tslint:disable
    if (debug) {
        const logColor = `color:${colorsMap[identifier]}`;
        extra && console[type](`%c******** address: ${identifier}********`, logColor);
        console[type](msg);
        extra &&
            Object.keys(extra).forEach((key) => {
                if (Array.isArray(extra[key])) {
                    Object.values(extra[key]).forEach((props) => {
                        console[type](`${key}: ${JSON.stringify(props.qualifier || props, null, 2)}`);
                    });
                }
                else {
                    console[type](`${key}: ${JSON.stringify(extra[key], null, 2)}`);
                }
            });
    }
    // tslint:enable
};

const getQualifier = ({ serviceName, methodName }) => `${serviceName}/${methodName}`;

const validateServiceDefinition = (definition) => {
    assertNonEmptyObject(definition);
    const { serviceName, methods } = definition;
    assertDefined(serviceName, SERVICE_NAME_NOT_PROVIDED);
    assertNonEmptyString(serviceName, getServiceNameInvalid(serviceName));
    assertDefined(methods, DEFINITION_MISSING_METHODS);
    assertNonEmptyObject(methods, INVALID_METHODS);
    Object.keys(methods).forEach((methodName) => {
        assertNonEmptyString(methodName);
        const qualifier = getQualifier({ serviceName, methodName });
        validateAsyncModel(qualifier, methods[methodName]);
    });
};
const validateAsyncModel = (qualifier, val) => {
    assertNonEmptyObject(val, getIncorrectMethodValueError(qualifier));
    const { asyncModel } = val;
    assertDefined(asyncModel, getAsynModelNotProvidedError(qualifier));
    assertOneOf(ASYNC_MODEL_TYPES, asyncModel, getInvalidAsyncModelError(qualifier));
};

// polyfill MessagePort and MessageChannel
class MessagePortPolyfill {
    constructor(whoami) {
        this.onmessage = null;
        this.onmessageerror = null;
        this.otherPort = null;
        this.onmessageListeners = [];
        this.queue = [];
        this.otherSideStart = false;
        this.whoami = whoami;
    }
    dispatchEvent(event) {
        if (this.onmessage) {
            this.onmessage(event);
        }
        this.onmessageListeners.forEach((listener) => listener(event));
        return true;
    }
    postMessage(message, ports) {
        const event = {
            ports,
            data: message,
        };
        if (!this.otherPort) {
            return;
        }
        if (this.otherSideStart) {
            this.otherPort.dispatchEvent(event);
        }
        else {
            this.queue.push(event);
        }
    }
    addEventListener(type, listener) {
        if (type !== 'message') {
            return;
        }
        if (typeof listener !== 'function' || this.onmessageListeners.indexOf(listener) !== -1) {
            return;
        }
        this.onmessageListeners.push(listener);
    }
    removeEventListener(type, listener) {
        if (type !== 'message') {
            return;
        }
        const index = this.onmessageListeners.indexOf(listener);
        if (index === -1) {
            return;
        }
        this.onmessageListeners.splice(index, 1);
    }
    start() {
        setTimeout(() => this.otherPort && this.otherPort.startSending.apply(this.otherPort, []), 0);
    }
    close() {
        setTimeout(() => this.otherPort && this.otherPort.stopSending.apply(this.otherPort, []), 0);
    }
    startSending() {
        this.otherSideStart = true;
        this.queue.forEach((event) => this.otherPort && this.otherPort.dispatchEvent(event));
    }
    stopSending() {
        this.otherSideStart = false;
        this.queue.length = 0;
    }
}
// tslint:disable-next-line
class MessageChannelPolyfill {
    constructor() {
        this.port1 = new MessagePortPolyfill('client');
        this.port2 = new MessagePortPolyfill('server');
        this.port1.otherPort = this.port2;
        this.port2.otherPort = this.port1;
    }
}
const globalObj = typeof window !== 'undefined' && window.Math === Math
    ? window
    : typeof self !== 'undefined' && self.Math === Math
        ? self
        : Function('return this')();
function applyMessageChannelPolyfill() {
    globalObj.MessagePort = MessagePortPolyfill;
    globalObj.MessageChannel = MessageChannelPolyfill;
}
if (!globalObj.MessagePort || !globalObj.MessageChannel) {
    applyMessageChannelPolyfill();
}

const workers = !isNodejs() ? { addWorker, removeWorker, initialize, addIframe } : {};

var INVALID_ITEMS_TO_PUBLISH = 'itemsToPublish are not of type Array';
var NODEJS_MUST_PROVIDE_CLUSTER_IMPL = 'Must provide cluster when running on nodejs';
var getAddressCollision = function (address, seedAddress) {
    return "address " + address + " must be different from the seed Address " + seedAddress;
};
var getDiscoverySuccessfullyDestroyedMessage = function (address) {
    return getFullAddress(address) + " has been removed";
};

var createDiscovery = function (options) {
    var address = options.address, itemsToPublish = options.itemsToPublish, seedAddress = options.seedAddress, debug = options.debug;
    var joinCluster = options.cluster;
    var discoveredItemsSubject = new ReplaySubject();
    if (!joinCluster) {
        saveToLogs(getFullAddress(address), NODEJS_MUST_PROVIDE_CLUSTER_IMPL, {}, debug, 'warn');
        discoveredItemsSubject.complete();
        return {
            destroy: function () { return Promise.resolve(NODEJS_MUST_PROVIDE_CLUSTER_IMPL); },
            discoveredItems$: function () { return discoveredItemsSubject.asObservable(); },
        };
    }
    var membersState = {};
    validateAddress(address, false);
    if (seedAddress) {
        seedAddress.forEach(function (seed) {
            validateAddress(seed, false);
            validateAddressCollision(address, seed);
        });
    }
    assertArray(itemsToPublish, INVALID_ITEMS_TO_PUBLISH);
    var cluster = joinCluster({ address: address, seedAddress: seedAddress, itemsToPublish: itemsToPublish, debug: false });
    var clusterListener = cluster.listen$();
    var subscription;
    return Object.freeze({
        destroy: function () {
            subscription && subscription.unsubscribe();
            discoveredItemsSubject.complete();
            return new Promise(function (resolve, reject) {
                cluster
                    .destroy()
                    .then(function () { return resolve(getDiscoverySuccessfullyDestroyedMessage(address)); })
                    .catch(function (error) { return reject(error); });
            });
        },
        discoveredItems$: function () {
            cluster
                .getCurrentMembersData()
                .then(function (currentMembersState) {
                var members = Object.keys(currentMembersState);
                members.forEach(function (member) {
                    var memberItem = currentMembersState[member];
                    if (memberItem.length === 0) {
                        discoveredItemsSubject.next({
                            type: 'IDLE',
                            items: [],
                        });
                    }
                    else {
                        if (!membersState[member]) {
                            membersState[member] = true;
                            discoveredItemsSubject.next({
                                type: 'REGISTERED',
                                items: memberItem,
                            });
                        }
                    }
                });
            })
                .catch(function (error) { return discoveredItemsSubject.error(error); });
            subscription = clusterListener.subscribe(function (clusterEvent) {
                var type = clusterEvent.type, items = clusterEvent.items, from = clusterEvent.from;
                if (items.length > 0) {
                    if (type === 'REMOVED' && membersState[from]) {
                        membersState[from] = false;
                        discoveredItemsSubject.next({
                            type: 'UNREGISTERED',
                            items: items,
                        });
                    }
                    if (type !== 'REMOVED' && !membersState[from]) {
                        membersState[from] = true;
                        discoveredItemsSubject.next({
                            type: 'REGISTERED',
                            items: items,
                        });
                    }
                }
            }, function (error) { return discoveredItemsSubject.error(error); }, function () { return discoveredItemsSubject.complete(); });
            return discoveredItemsSubject.asObservable();
        },
    });
};
var validateAddressCollision = function (address, seedAddress) {
    var fullAddress = getFullAddress(address);
    var fullSeedAddress = getFullAddress(seedAddress);
    if (fullAddress === fullSeedAddress) {
        throw new Error(getAddressCollision(fullAddress, fullSeedAddress));
    }
};

var ASYNC_MODEL_TYPES$1 = ASYNC_MODEL_TYPES;
var MICROSERVICE_NOT_EXISTS = 'MS0000 - microservice does not exists';
var MESSAGE_NOT_PROVIDED = 'MS0001 - Message has not been provided';
var MESSAGE_DATA_NOT_PROVIDED = 'MS0002 - Message data has not been provided';
var MESSAGE_QUALIFIER_NOT_PROVIDED = 'MS0003 - Message qualifier has not been provided';
var INVALID_MESSAGE = 'MS0004 - Message should not to be empty object';
var INVALID_QUALIFIER = 'MS0005 - qualifier expected to be service/method format';
var SERVICE_DEFINITION_NOT_PROVIDED = 'MS0006 - Service missing definition';
var WRONG_DATA_FORMAT_IN_MESSAGE = 'MS0007 - Message format error: data must be Array';
var SERVICES_IS_NOT_ARRAY = 'MS0008 - Not valid format, services must be an Array';
var SERVICE_IS_NOT_OBJECT = 'MS0009 - Not valid format, service must be an Object';
var MICROSERVICE_OPTIONS_IS_NOT_OBJECT = 'MS0000 - Not valid format, MicroserviceOptions must be an Object';
var QUALIFIER_IS_NOT_STRING = 'MS0011 - qualifier should not be empty string';
var TRANSPORT_NOT_PROVIDED = 'MS0013 - Transport provider is not define';
var ROUTER_NOT_PROVIDED = 'MS0024 - Router is not define';
var INVALID_ASYNC_MODEL = 'MS0028 - invalid async model';
var getServiceMethodIsMissingError = function (methodName) {
    return "MS0014 - service method '" + methodName + "' missing in the serviceDefinition";
};
var getNotFoundByRouterError = function (whoAmI, qualifier) {
    return "MS0015 - " + whoAmI + " can't find services that match the give criteria: '" + JSON.stringify(qualifier) + "'";
};
var getAsyncModelMissmatch = function (expectedAsyncModel, receivedAsyncModel) { return "MS0016 - asyncModel does not match, expect " + expectedAsyncModel + ", but received " + receivedAsyncModel; };
var getMethodNotFoundError = function (message) { return "Can't find method " + message.qualifier; };
var getInvalidMethodReferenceError = function (qualifier) {
    return "MS0017 - service (" + qualifier + ") has valid definition but reference is not a function.";
};
var getServiceReferenceNotProvidedError = function (serviceName) {
    return "MS0018 - service does not uphold the contract, " + serviceName + " is not provided";
};
var getInvalidServiceReferenceError = function (serviceName) {
    return "MS0019 - Not valid format, " + serviceName + " reference must be an Object";
};
var getIncorrectServiceImplementForPromise = function (whoAmI, qualifier) {
    return "MS0025 - " + whoAmI + "'s service '" + qualifier + "' define as Promise but service return not Promise";
};
var getIncorrectServiceImplementForObservable = function (whoAmI, qualifier) {
    return "MS0026 - " + whoAmI + "'s service '" + qualifier + "' define as Observable but service return not Observable";
};
var getIncorrectServiceInvoke = function (whoAmI, qualifier) {
    return "MS0027 - " + whoAmI + "'s " + qualifier + " has no valid response, expect Promise or Observable";
};
var NO_PROXY_SUPPORT = 'MS0029 - Proxy not supported, please add Proxy polyfill';

var validateMicroserviceOptions = function (microserviceOptions) {
    assertObject(microserviceOptions, MICROSERVICE_OPTIONS_IS_NOT_OBJECT);
    var services = microserviceOptions.services, seedAddress = microserviceOptions.seedAddress, address = microserviceOptions.address;
    if (typeof seedAddress !== 'undefined') {
        asserNotEmptytArray(seedAddress, NOT_VALID_ADDRESS);
        seedAddress.forEach(function (seed) {
            validateAddress(seed, true);
        });
    }
    validateAddress(address, true);
    validateMicroserviceServices(services);
};
var validateMicroserviceServices = function (services) {
    assertArray(services, SERVICES_IS_NOT_ARRAY);
    services.forEach(validateService);
};
var validateService = function (service) {
    assertNonEmptyObject(service, SERVICE_IS_NOT_OBJECT);
    var definition = service.definition, reference = service.reference;
    assertDefined(definition, SERVICE_DEFINITION_NOT_PROVIDED);
    validateServiceDefinition(definition);
    var serviceName = definition.serviceName;
    assertDefined(reference, getServiceReferenceNotProvidedError(serviceName));
};
var validateServiceReference = function (reference, definition) {
    var serviceName = definition.serviceName;
    assertObject(reference, getInvalidServiceReferenceError(serviceName));
    Object.keys(definition.methods).forEach(function (methodName) {
        var qualifier = getQualifier({ serviceName: serviceName, methodName: methodName });
        var staticMethodRef = reference.constructor && reference.constructor[methodName];
        assertFunction(reference[methodName] || staticMethodRef, getInvalidMethodReferenceError(qualifier));
    });
};
var validateMessage = function (message) {
    assertDefined(message, MESSAGE_NOT_PROVIDED);
    assertNonEmptyObject(message, INVALID_MESSAGE);
    var data = message.data, qualifier = message.qualifier;
    assertDefined(qualifier, MESSAGE_QUALIFIER_NOT_PROVIDED);
    validateQualifier(qualifier);
    assertDefined(data, MESSAGE_DATA_NOT_PROVIDED);
    assertArray(data, WRONG_DATA_FORMAT_IN_MESSAGE);
};
var validateQualifier = function (value) {
    assertNonEmptyString(value, QUALIFIER_IS_NOT_STRING);
    var parts = value.split('/');
    assert(parts.length === 2, INVALID_QUALIFIER);
    assertNonEmptyString(parts[0], INVALID_QUALIFIER);
    assertNonEmptyString(parts[1], INVALID_QUALIFIER);
};
var validateDiscoveryInstance = function (discovery) {
    assertDefined(discovery, '');
    var discoveredItems$ = discovery.discoveredItems$, destroy = discovery.destroy;
    assertDefined(discoveredItems$, '');
    assertDefined(destroy, '');
};

var serviceCallError = function (_a) {
    var errorMessage = _a.errorMessage, microserviceContext = _a.microserviceContext;
    var error = new Error(errorMessage);
    if (microserviceContext) {
        var whoAmI = microserviceContext.whoAmI, debug = microserviceContext.debug;
        saveToLogs(whoAmI, errorMessage, {}, debug, 'warn');
    }
    return error;
};

var throwException = function (asyncModel, message) {
    if (asyncModel === ASYNC_MODEL_TYPES$1.REQUEST_RESPONSE) {
        return Promise.reject(message);
    }
    else {
        return new Observable(function (obs) {
            obs.error(message);
        });
    }
};
var localCall = function (_a) {
    var localService = _a.localService, asyncModel = _a.asyncModel, message = _a.message, microserviceContext = _a.microserviceContext;
    var reference = localService.reference, asyncModelProvider = localService.asyncModel;
    var method = reference && reference[localService.methodName];
    if (!method) {
        return throwException(asyncModel, serviceCallError({
            errorMessage: getMethodNotFoundError(message),
            microserviceContext: microserviceContext,
        }));
    }
    if (asyncModelProvider !== asyncModel) {
        return throwException(asyncModel, serviceCallError({
            errorMessage: getAsyncModelMissmatch(asyncModel, asyncModelProvider),
            microserviceContext: microserviceContext,
        }));
    }
    var invoke = method.apply(void 0, message.data);
    if (typeof invoke !== 'object' || !invoke) {
        return throwException(asyncModel, serviceCallError({
            errorMessage: getIncorrectServiceInvoke(microserviceContext.whoAmI, message.qualifier),
            microserviceContext: microserviceContext,
        }));
    }
    switch (asyncModel) {
        case ASYNC_MODEL_TYPES$1.REQUEST_STREAM:
            return new Observable(function (obs) {
                if (isFunction(invoke.subscribe)) {
                    var s_1 = invoke.subscribe(function () {
                        var data = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            data[_i] = arguments[_i];
                        }
                        return obs.next.apply(obs, data);
                    }, function (err) { return obs.error(err); }, function () { return obs.complete(); });
                    return function () { return s_1.unsubscribe(); };
                }
                obs.error(serviceCallError({
                    errorMessage: getIncorrectServiceImplementForObservable(microserviceContext.whoAmI, message.qualifier),
                    microserviceContext: microserviceContext,
                }));
            });
        case ASYNC_MODEL_TYPES$1.REQUEST_RESPONSE:
            return new Promise(function (resolve, reject) {
                isFunction(invoke.then)
                    ? invoke.then(resolve).catch(reject)
                    : reject(serviceCallError({
                        errorMessage: getIncorrectServiceImplementForPromise(microserviceContext.whoAmI, message.qualifier),
                        microserviceContext: microserviceContext,
                    }));
            });
        default:
            return throwException(asyncModel, serviceCallError({
                errorMessage: INVALID_ASYNC_MODEL,
                microserviceContext: microserviceContext,
            }));
    }
};

var loggerUtil = function (whoAmI, debug) { return function (msg, type) {
    saveToLogs(whoAmI, msg, {}, debug, type);
}; };

var remoteCall = function (options) {
    var asyncModel = options.asyncModel, transportClient = options.transportClient, microserviceContext = options.microserviceContext, message = options.message;
    var logger = loggerUtil(microserviceContext.whoAmI, microserviceContext.debug);
    switch (asyncModel) {
        case ASYNC_MODEL_TYPES$1.REQUEST_STREAM:
            var canceled_1 = false;
            var cancel_1 = function () {
                canceled_1 = true;
            };
            return new Observable(function (obs) {
                getValidEndpoint(options)
                    .then(function (endpoint) {
                    transportClient
                        .start({ remoteAddress: endpoint.address, logger: logger })
                        .then(function (_a) {
                        var requestStream = _a.requestStream;
                        if (canceled_1) {
                            return;
                        }
                        var sub = requestStream(message).subscribe(function (data) { return obs.next(data); }, function (err) { return obs.error(err); }, function () { return obs.complete(); });
                        cancel_1 = function () { return sub.unsubscribe(); };
                    })
                        .catch(function (error) { return obs.error(error); });
                })
                    .catch(function (error) { return obs.error(error); });
                return function () { return cancel_1(); };
            });
        case ASYNC_MODEL_TYPES$1.REQUEST_RESPONSE:
            return new Promise(function (resolve, reject) {
                getValidEndpoint(options)
                    .then(function (endpoint) {
                    transportClient
                        .start({ remoteAddress: endpoint.address, logger: logger })
                        .then(function (_a) {
                        var requestResponse = _a.requestResponse;
                        requestResponse(message)
                            .then(function (response) { return resolve(response); })
                            .catch(function (e) { return reject(e); });
                    })
                        .catch(function (e) { return reject(e); });
                })
                    .catch(function (e) { return reject(e); });
            });
        default:
            throw new Error('invalid async model');
    }
};
var getValidEndpoint = function (_a) {
    var router = _a.router, microserviceContext = _a.microserviceContext, message = _a.message, asyncModel = _a.asyncModel, transportClient = _a.transportClient;
    return new Promise(function (resolve, reject) {
        router({ lookUp: microserviceContext.remoteRegistry.lookUp, message: message })
            .then(function (endPoint) {
            var asyncModelProvider = endPoint.asyncModel;
            if (asyncModelProvider !== asyncModel) {
                reject(serviceCallError({
                    errorMessage: getAsyncModelMissmatch(asyncModel, asyncModelProvider),
                    microserviceContext: microserviceContext,
                }));
            }
            if (!transportClient) {
                reject(serviceCallError({
                    errorMessage: TRANSPORT_NOT_PROVIDED,
                    microserviceContext: microserviceContext,
                }));
            }
            resolve(endPoint);
        })
            .catch(function () {
            reject(serviceCallError({
                errorMessage: getNotFoundByRouterError(microserviceContext.whoAmI, message.qualifier),
                microserviceContext: microserviceContext,
            }));
        });
    });
};

var getServiceCall = function (options) {
    var router = options.router, microserviceContext = options.microserviceContext, transportClient = options.transportClient;
    return function (_a) {
        var message = _a.message, asyncModel = _a.asyncModel;
        try {
            validateMessage(message);
        }
        catch (e) {
            var err = serviceCallError({ errorMessage: e.message, microserviceContext: microserviceContext });
            return asyncModel === ASYNC_MODEL_TYPES$1.REQUEST_RESPONSE ? Promise.reject(err) : throwError(err);
        }
        var localService = microserviceContext.localRegistry.lookUp({ qualifier: message.qualifier });
        return localService
            ? localCall({ localService: localService, asyncModel: asyncModel, message: message, microserviceContext: microserviceContext })
            : remoteCall({ router: router, microserviceContext: microserviceContext, message: message, asyncModel: asyncModel, transportClient: transportClient });
    };
};
var createServiceCall = function (options) {
    var router = options.router, microserviceContext = options.microserviceContext, transportClient = options.transportClient;
    if (!microserviceContext) {
        throw new Error(MICROSERVICE_NOT_EXISTS);
    }
    var serviceCall = getServiceCall({ router: router, microserviceContext: microserviceContext, transportClient: transportClient });
    return Object.freeze({
        requestStream: function (message) {
            return serviceCall({
                message: message,
                asyncModel: ASYNC_MODEL_TYPES$1.REQUEST_STREAM,
            });
        },
        requestResponse: function (message) {
            return serviceCall({
                message: message,
                asyncModel: ASYNC_MODEL_TYPES$1.REQUEST_RESPONSE,
            });
        },
    });
};

var createRemoteRegistry = function () {
    var remoteRegistryMap = {};
    return Object.freeze({
        lookUp: function (_a) {
            var qualifier = _a.qualifier;
            if (!remoteRegistryMap) {
                throw new Error(MICROSERVICE_NOT_EXISTS);
            }
            return remoteRegistryMap[qualifier] || [];
        },
        createEndPoints: function (options) {
            if (!remoteRegistryMap) {
                throw new Error(MICROSERVICE_NOT_EXISTS);
            }
            return getEndpointsFromServices(options); // all services => endPoints[]
        },
        update: function (_a) {
            var type = _a.type, items = _a.items;
            if (type === 'IDLE') {
                return;
            }
            if (!remoteRegistryMap) {
                throw new Error(MICROSERVICE_NOT_EXISTS);
            }
            remoteRegistryMap = updatedRemoteRegistry({ type: type, items: items, remoteRegistryMap: remoteRegistryMap });
        },
        destroy: function () {
            remoteRegistryMap = null;
        },
    });
};
// Helpers
var getEndpointsFromServices = function (options) {
    var services = options.services, address = options.address;
    return services && address
        ? services.reduce(function (res, service) { return __spreadArrays(res, getEndpointsFromService({ service: service, address: address })); }, [])
        : [];
};
var updatedRemoteRegistry = function (_a) {
    var type = _a.type, items = _a.items, remoteRegistryMap = _a.remoteRegistryMap;
    switch (type) {
        case 'REGISTERED':
            remoteRegistryMap = items.reduce(function (res, endpoint) {
                var _a;
                return (__assign(__assign({}, res), (_a = {}, _a[endpoint.qualifier] = __spreadArrays((res[endpoint.qualifier] || []), [endpoint]), _a)));
            }, remoteRegistryMap || {});
            break;
        case 'UNREGISTERED':
            items.forEach(function (unregisteredEndpoint) {
                remoteRegistryMap[unregisteredEndpoint.qualifier] = remoteRegistryMap[unregisteredEndpoint.qualifier].filter(function (registryEndpoint) {
                    return getFullAddress(registryEndpoint.address) !== getFullAddress(unregisteredEndpoint.address);
                });
            });
            break;
    }
    return __assign({}, remoteRegistryMap);
};
var getEndpointsFromService = function (_a) {
    var service = _a.service, address = _a.address;
    var definition = service.definition;
    var serviceName = definition.serviceName, methods = definition.methods;
    return (Object.keys(methods).map(function (methodName) { return ({
        qualifier: getQualifier({ serviceName: serviceName, methodName: methodName }),
        serviceName: serviceName,
        methodName: methodName,
        asyncModel: methods[methodName].asyncModel,
        address: address,
    }); }) || []);
};

var getReferencePointer = function (_a) {
    var reference = _a.reference, methodName = _a.methodName;
    var methodRef = reference[methodName];
    if (methodRef) {
        return methodRef.bind(reference);
    }
    // static method
    return reference.constructor && reference.constructor[methodName];
};
var flatteningServices = function (_a) {
    var services = _a.services, serviceFactoryOptions = _a.serviceFactoryOptions;
    return services && Array.isArray(services)
        ? services.map(function (service) {
            var reference = service.reference, definition = service.definition;
            if (isFunction(reference)) {
                var ref = reference(serviceFactoryOptions);
                validateServiceReference(ref, definition);
                return { reference: ref, definition: definition };
            }
            else {
                validateServiceReference(reference, definition);
                return { reference: reference, definition: definition };
            }
        })
        : services;
};

var createLocalRegistry = function () {
    var localRegistryMap = {};
    return Object.freeze({
        lookUp: function (_a) {
            var qualifier = _a.qualifier;
            if (!localRegistryMap) {
                throw new Error(MICROSERVICE_NOT_EXISTS);
            }
            return localRegistryMap[qualifier] || null;
        },
        add: function (_a) {
            var _b = _a.services, services = _b === void 0 ? [] : _b;
            if (!localRegistryMap) {
                throw new Error(MICROSERVICE_NOT_EXISTS);
            }
            var references = getReferenceFromServices({ services: services });
            localRegistryMap = getUpdatedLocalRegistry({
                localRegistryMap: localRegistryMap,
                references: references,
            });
        },
        destroy: function () {
            localRegistryMap = null;
        },
    });
};
// Helpers
var getReferenceFromServices = function (_a) {
    var _b = _a.services, services = _b === void 0 ? [] : _b;
    return services.reduce(function (res, service) { return __spreadArrays(res, getReferenceFromService({
        service: service,
    })); }, []);
};
var getUpdatedLocalRegistry = function (_a) {
    var localRegistryMap = _a.localRegistryMap, references = _a.references;
    return (__assign(__assign({}, localRegistryMap), references.reduce(function (res, reference) {
        var _a;
        return (__assign(__assign({}, res), (_a = {}, _a[reference.qualifier] = reference, _a)));
    }, localRegistryMap || {})));
};
var getReferenceFromService = function (_a) {
    var service = _a.service;
    var data = [];
    var definition = service.definition, reference = service.reference;
    var serviceName = definition.serviceName, methods = definition.methods;
    Object.keys(methods).forEach(function (methodName) {
        var _a;
        var qualifier = getQualifier({ serviceName: serviceName, methodName: methodName });
        data.push({
            qualifier: qualifier,
            serviceName: serviceName,
            methodName: methodName,
            asyncModel: methods[methodName].asyncModel,
            reference: (_a = {},
                _a[methodName] = getReferencePointer({ reference: reference, methodName: methodName }),
                _a),
        });
    });
    return data;
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction$1(x) {
    return typeof x === 'function';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = /*@__PURE__*/ new Error();
            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}

/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError(err);
        }
    },
    complete: function () { }
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray$1 = /*@__PURE__*/ (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject$1(x) {
    return x !== null && typeof x === 'object';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var UnsubscriptionErrorImpl = /*@__PURE__*/ (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
var UnsubscriptionError = UnsubscriptionErrorImpl;

/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
var Subscription = /*@__PURE__*/ (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if (isFunction$1(_unsubscribe)) {
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (isArray$1(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject$1(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber = /*@__PURE__*/ (function () {
    return typeof Symbol === 'function'
        ? /*@__PURE__*/ Symbol('rxSubscriber')
        : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();
})();

/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
var Subscriber = /*@__PURE__*/ (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(Subscription));
var SafeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction$1(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== empty) {
                context = Object.create(observerOrNext);
                if (isFunction$1(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function noop() { }

/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
var DoOperator = /*@__PURE__*/ (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop;
        _this._tapError = noop;
        _this._tapComplete = noop;
        _this._tapError = error || noop;
        _this._tapComplete = complete || noop;
        if (isFunction$1(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || noop;
            _this._tapError = observerOrNext.error || noop;
            _this._tapComplete = observerOrNext.complete || noop;
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(Subscriber));

var getProxy = function (_a) {
    var serviceCall = _a.serviceCall, serviceDefinition = _a.serviceDefinition;
    // workaround to support old browsers
    var obj = {};
    Object.keys(serviceDefinition.methods).forEach(function (key) {
        return (obj[key] = function () {
            throw Error(NO_PROXY_SUPPORT);
        });
    });
    return new Proxy(obj, {
        get: preServiceCall({ serviceDefinition: serviceDefinition, serviceCall: serviceCall }),
    });
};
var preServiceCall = function (_a) {
    var serviceCall = _a.serviceCall, serviceDefinition = _a.serviceDefinition;
    return function (target, prop) {
        if (!serviceDefinition.methods[prop]) {
            throw new Error(getServiceMethodIsMissingError(prop));
        }
        var asyncModel = serviceDefinition.methods[prop].asyncModel;
        return function () {
            var data = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                data[_i] = arguments[_i];
            }
            var message = {
                qualifier: getQualifier({ serviceName: serviceDefinition.serviceName, methodName: prop }),
                data: data,
            };
            return serviceCall({ message: message, asyncModel: asyncModel });
        };
    };
};

var createProxy = function (proxyOptions) {
    var router = proxyOptions.router, serviceDefinition = proxyOptions.serviceDefinition, microserviceContext = proxyOptions.microserviceContext, transportClient = proxyOptions.transportClient;
    if (!microserviceContext) {
        throw new Error(MICROSERVICE_NOT_EXISTS);
    }
    validateServiceDefinition(serviceDefinition);
    return getProxy({
        serviceCall: getServiceCall({ router: router, microserviceContext: microserviceContext, transportClient: transportClient }),
        serviceDefinition: serviceDefinition,
    });
};

var destroy = function (options) {
    var discovery = options.discovery, serverStop = options.serverStop, transportClientDestroy = options.transportClientDestroy;
    var microserviceContext = options.microserviceContext;
    if (!microserviceContext) {
        throw new Error(MICROSERVICE_NOT_EXISTS);
    }
    var logger = loggerUtil(microserviceContext.whoAmI, microserviceContext.debug);
    return new Promise(function (resolve, reject) {
        if (microserviceContext) {
            var localRegistry = microserviceContext.localRegistry, remoteRegistry = microserviceContext.remoteRegistry;
            localRegistry.destroy();
            remoteRegistry.destroy();
            transportClientDestroy({ address: microserviceContext.whoAmI, logger: logger });
        }
        serverStop && serverStop();
        discovery &&
            discovery.destroy().then(function () {
                resolve('');
                microserviceContext = null;
            });
    });
};

var setMicroserviceInstance = function (options) {
    var transportClient = options.transportClient, serverStop = options.serverStop, discoveryInstance = options.discoveryInstance, debug = options.debug, defaultRouter = options.defaultRouter, microserviceContext = options.microserviceContext;
    var remoteRegistry = microserviceContext.remoteRegistry;
    discoveryInstance &&
        discoveryInstance
            .discoveredItems$()
            .pipe(printLogs(microserviceContext.whoAmI, debug))
            .subscribe(remoteRegistry.update);
    var serviceFactoryOptions = getServiceFactoryOptions({
        microserviceContext: microserviceContext,
        transportClient: transportClient,
        defaultRouter: defaultRouter,
    });
    return Object.freeze(__assign({ destroy: function () {
            return destroy({
                microserviceContext: microserviceContext,
                discovery: discoveryInstance,
                serverStop: serverStop,
                transportClientDestroy: transportClient.destroy,
            });
        } }, serviceFactoryOptions));
};
var getServiceFactoryOptions = function (_a) {
    var microserviceContext = _a.microserviceContext, transportClient = _a.transportClient, defaultRouter = _a.defaultRouter;
    return ({
        createProxy: function (_a) {
            var serviceDefinition = _a.serviceDefinition, _b = _a.router, router = _b === void 0 ? defaultRouter : _b;
            return createProxy({
                serviceDefinition: serviceDefinition,
                router: router,
                microserviceContext: microserviceContext,
                transportClient: transportClient,
            });
        },
        createServiceCall: function (_a) {
            var _b = _a.router, router = _b === void 0 ? defaultRouter : _b;
            return createServiceCall({
                router: router,
                microserviceContext: microserviceContext,
                transportClient: transportClient,
            });
        },
    });
};
var printLogs = function (whoAmI, debug) {
    return tap(function (_a) {
        var _b;
        var type = _a.type, items = _a.items;
        return type !== 'IDLE' &&
            saveToLogs(whoAmI, "microservice received an updated", (_b = {},
                _b[type] = items.map(function (item) { return item.qualifier; }),
                _b), debug);
    });
};

var createMicroservice = function (options) {
    var microserviceOptions = __assign({ defaultRouter: function () {
            throw new Error(ROUTER_NOT_PROVIDED);
        }, services: [], debug: false, transport: {
            clientTransport: {
                start: function () {
                    throw new Error('client transport not provided');
                },
            },
            serverTransport: function () {
                throw new Error('server transport not provided');
            },
        } }, options);
    if (isString(microserviceOptions.address)) {
        microserviceOptions = __assign(__assign({}, microserviceOptions), { address: getAddress(microserviceOptions.address) });
    }
    microserviceOptions = __assign(__assign({}, microserviceOptions), { seedAddress: !!microserviceOptions.seedAddress
            ? multiSeedSupport(microserviceOptions.seedAddress)
            : microserviceOptions.seedAddress });
    validateMicroserviceOptions(microserviceOptions);
    var cluster = microserviceOptions.cluster, debug = microserviceOptions.debug;
    var transport = microserviceOptions.transport;
    var address = microserviceOptions.address;
    var seedAddress = microserviceOptions.seedAddress;
    var transportClient = transport.clientTransport;
    var fallBackAddress = address || getAddress(Date.now().toString());
    // tslint:disable-next-line
    var microserviceContext = createMicroserviceContext({
        address: fallBackAddress,
        debug: debug || false,
    });
    var remoteRegistry = microserviceContext.remoteRegistry, localRegistry = microserviceContext.localRegistry;
    var serviceFactoryOptions = getServiceFactoryOptions({
        microserviceContext: microserviceContext,
        transportClient: transportClient,
        defaultRouter: microserviceOptions.defaultRouter,
    });
    var services = microserviceOptions
        ? flatteningServices({
            services: microserviceOptions.services,
            serviceFactoryOptions: serviceFactoryOptions,
        })
        : [];
    localRegistry.add({ services: services, address: address });
    // if address is not available then microservice can't share services
    var endPointsToPublishInCluster = address
        ? remoteRegistry.createEndPoints({
            services: services,
            address: address,
        }) || []
        : [];
    var discoveryInstance = createDiscovery({
        address: fallBackAddress,
        itemsToPublish: endPointsToPublishInCluster,
        seedAddress: seedAddress,
        cluster: cluster,
        debug: debug,
    });
    discoveryInstance && validateDiscoveryInstance(discoveryInstance);
    // if address is not available then microservice can't start a server and get serviceCall requests
    var serverStop = address && transport
        ? transport.serverTransport({
            logger: loggerUtil(microserviceContext.whoAmI, microserviceContext.debug),
            localAddress: address,
            serviceCall: createServiceCall({
                router: microserviceOptions.defaultRouter,
                microserviceContext: microserviceContext,
                transportClient: transportClient,
            }),
        })
        : function () { };
    return setMicroserviceInstance({
        microserviceContext: microserviceContext,
        transportClient: transportClient,
        discoveryInstance: discoveryInstance,
        serverStop: serverStop,
        debug: debug,
        defaultRouter: microserviceOptions.defaultRouter,
    });
};
var createMicroserviceContext = function (_a) {
    var address = _a.address, debug = _a.debug;
    var remoteRegistry = createRemoteRegistry();
    var localRegistry = createLocalRegistry();
    return {
        remoteRegistry: remoteRegistry,
        localRegistry: localRegistry,
        debug: debug,
        whoAmI: getFullAddress(address),
    };
};
var multiSeedSupport = function (seedAddress) {
    var seeds = [];
    if (!isArray(seedAddress)) {
        seeds = isString(seedAddress) ? [getAddress(seedAddress)] : [seedAddress];
    }
    else {
        seeds = seedAddress.map(function (val) {
            return isString(val) ? getAddress(val) : val;
        });
    }
    return seeds;
};

export { ASYNC_MODEL_TYPES$1 as ASYNC_MODEL_TYPES, createMicroservice };
