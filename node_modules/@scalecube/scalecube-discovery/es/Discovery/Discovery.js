import { ReplaySubject } from 'rxjs';
import { getFullAddress, validateAddress, check, saveToLogs } from '@scalecube/utils';
import { getAddressCollision, getDiscoverySuccessfullyDestroyedMessage, INVALID_ITEMS_TO_PUBLISH, NODEJS_MUST_PROVIDE_CLUSTER_IMPL, } from '../helpers/constants';
export var createDiscovery = function (options) {
    var address = options.address, itemsToPublish = options.itemsToPublish, seedAddress = options.seedAddress, debug = options.debug;
    var joinCluster = options.cluster;
    var discoveredItemsSubject = new ReplaySubject();
    if (!joinCluster) {
        saveToLogs(getFullAddress(address), NODEJS_MUST_PROVIDE_CLUSTER_IMPL, {}, debug, 'warn');
        discoveredItemsSubject.complete();
        return {
            destroy: function () { return Promise.resolve(NODEJS_MUST_PROVIDE_CLUSTER_IMPL); },
            discoveredItems$: function () { return discoveredItemsSubject.asObservable(); },
        };
    }
    var membersState = {};
    validateAddress(address, false);
    if (seedAddress) {
        seedAddress.forEach(function (seed) {
            validateAddress(seed, false);
            validateAddressCollision(address, seed);
        });
    }
    check.assertArray(itemsToPublish, INVALID_ITEMS_TO_PUBLISH);
    var cluster = joinCluster({ address: address, seedAddress: seedAddress, itemsToPublish: itemsToPublish, debug: false });
    var clusterListener = cluster.listen$();
    var subscription;
    return Object.freeze({
        destroy: function () {
            subscription && subscription.unsubscribe();
            discoveredItemsSubject.complete();
            return new Promise(function (resolve, reject) {
                cluster
                    .destroy()
                    .then(function () { return resolve(getDiscoverySuccessfullyDestroyedMessage(address)); })
                    .catch(function (error) { return reject(error); });
            });
        },
        discoveredItems$: function () {
            cluster
                .getCurrentMembersData()
                .then(function (currentMembersState) {
                var members = Object.keys(currentMembersState);
                members.forEach(function (member) {
                    var memberItem = currentMembersState[member];
                    if (memberItem.length === 0) {
                        discoveredItemsSubject.next({
                            type: 'IDLE',
                            items: [],
                        });
                    }
                    else {
                        if (!membersState[member]) {
                            membersState[member] = true;
                            discoveredItemsSubject.next({
                                type: 'REGISTERED',
                                items: memberItem,
                            });
                        }
                    }
                });
            })
                .catch(function (error) { return discoveredItemsSubject.error(error); });
            subscription = clusterListener.subscribe(function (clusterEvent) {
                var type = clusterEvent.type, items = clusterEvent.items, from = clusterEvent.from;
                if (items.length > 0) {
                    if (type === 'REMOVED' && membersState[from]) {
                        membersState[from] = false;
                        discoveredItemsSubject.next({
                            type: 'UNREGISTERED',
                            items: items,
                        });
                    }
                    if (type !== 'REMOVED' && !membersState[from]) {
                        membersState[from] = true;
                        discoveredItemsSubject.next({
                            type: 'REGISTERED',
                            items: items,
                        });
                    }
                }
            }, function (error) { return discoveredItemsSubject.error(error); }, function () { return discoveredItemsSubject.complete(); });
            return discoveredItemsSubject.asObservable();
        },
    });
};
var validateAddressCollision = function (address, seedAddress) {
    var fullAddress = getFullAddress(address);
    var fullSeedAddress = getFullAddress(seedAddress);
    if (fullAddress === fullSeedAddress) {
        throw new Error(getAddressCollision(fullAddress, fullSeedAddress));
    }
};
