'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var rsocketCore = require('rsocket-core');
var RSocketWebSocketServer = _interopDefault(require('rsocket-websocket-server'));
var rsocketFlowable = require('rsocket-flowable');
var utils = require('@scalecube/utils');

var singleHandler = function (serviceCall, data, subscriber) {
    subscriber.onSubscribe();
    serviceCall
        .requestResponse(data)
        .then(function (resp) {
        // console.log('RESP', resp);
        subscriber.onComplete({ data: resp });
    })
        .catch(function (err) {
        subscriber.onError(err);
    });
};
var requestResponse = function (_a, serviceCall, handler) {
    var data = _a.data;
    if (handler === void 0) { handler = singleHandler; }
    return new rsocketFlowable.Single(handler.bind(null, serviceCall, data));
};

var flowableHandler = function (serviceCall, data, subscriber) {
    var sub;
    subscriber.onSubscribe({
        cancel: function () {
            sub && sub.unsubscribe();
        },
        request: function () {
            sub = serviceCall.requestStream(data).subscribe(function (response) {
                subscriber.onNext({ data: response });
            }, function (error) { return subscriber.onError(error); }, function () { return subscriber.onComplete(); });
        },
    });
};
var requestStream = function (_a, serviceCall, handler) {
    var data = _a.data;
    if (handler === void 0) { handler = flowableHandler; }
    return new rsocketFlowable.Flowable(handler.bind(null, serviceCall, data));
};

var SERVICE_CALL_MUST_BE_OBJECT = 'service call must be an object';
var REQUEST_STREAM_MUST_BE_FUNCTION = 'requestStream must be a function';
var REQUEST_RESPONSE_MUST_BE_FUNCTION = 'requestResponse must be a function';
var getInvalidRequestHandler = function (name, type) {
    return "invalid custom " + name + ", receive " + type + " instead of Function";
};

var validateCustomHandlers = function (name, customHandler) {
    if (!utils.check.isDefined(customHandler)) {
        return;
    }
    utils.check.assertFunction(customHandler, getInvalidRequestHandler(name, typeof customHandler));
};
var validateServiceCall = function (serviceCall) {
    utils.check.assertObject(serviceCall, SERVICE_CALL_MUST_BE_OBJECT);
    var requestResponse = serviceCall.requestResponse, requestStream = serviceCall.requestStream;
    utils.check.assertFunction(requestResponse, REQUEST_RESPONSE_MUST_BE_FUNCTION);
    utils.check.assertFunction(requestStream, REQUEST_STREAM_MUST_BE_FUNCTION);
};

var Gateway = /** @class */ (function () {
    function Gateway(opts) {
        this.started = false;
        var port = opts.port;
        this.port = port || 3000;
        this.transport = new RSocketWebSocketServer({ port: this.port });
        var optRequestResponse = opts.requestResponse, optRequestStream = opts.requestStream;
        validateCustomHandlers('requestResponse', optRequestResponse);
        validateCustomHandlers('requestStream', optRequestStream);
        this.requestResponse = optRequestResponse;
        this.requestStream = optRequestStream;
    }
    Gateway.prototype.start = function (opts) {
        var _this = this;
        if (this.started) {
            this.warn('Gateway is already started');
            return;
        }
        var serviceCall = opts.serviceCall;
        validateServiceCall(serviceCall);
        this.server = new rsocketCore.RSocketServer({
            serializers: rsocketCore.JsonSerializers,
            getRequestHandler: function (socket) {
                return {
                    requestResponse: function (payload) {
                        return requestResponse(payload, serviceCall, _this.requestResponse);
                    },
                    requestStream: function (payload) { return requestStream(payload, serviceCall, _this.requestStream); },
                };
            },
            transport: this.transport,
        });
        this.server.start();
        // console.log('Gateway started on port: ' + this.port);
        this.started = true;
    };
    Gateway.prototype.stop = function () {
        if (!this.started) {
            this.warn('Gateway is already stopped');
            return;
        }
        this.server.stop();
        // console.log('Gateway stopped');
        this.started = false;
    };
    Gateway.prototype.warn = function (message) {
        console.warn(message);
    };
    return Gateway;
}());

module.exports = Gateway;
