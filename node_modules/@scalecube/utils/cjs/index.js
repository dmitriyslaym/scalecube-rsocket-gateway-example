'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const assert = (predicate, msg) => {
    if (!predicate) {
        throw new Error(msg);
    }
};
const isDefined = (val) => typeof val !== 'undefined';
const assertDefined = (val, msg = 'Expect to be defined') => {
    assert(isDefined(val), msg);
};
const isString = (val) => typeof val === 'string' || val instanceof String;
const assertString = (val, msg = 'Expected to be a string') => {
    assert(isDefined(val) && isString(val), msg);
};
const assertNonEmptyString = (val, msg = 'Expected to be non empty string') => {
    assertString(val, msg);
    assert(val.length > 0, msg);
};
const isArray = (val) => Array.isArray(val);
const isNonEmptyArray = (val) => isArray(val) && val.length > 0;
const assertArray = (val, msg = 'Expected to be an array') => {
    assert(isArray(val), msg);
};
const asserNotEmptytArray = (val, msg = 'Expected to be an array') => {
    assert(isNonEmptyArray(val), msg);
};
const isObject = (val) => Object.prototype.toString.call(val) === '[object Object]';
const assertObject = (val, msg = 'Expected to be an object') => {
    assert(isObject(val), msg);
};
const assertNonEmptyObject = (val, msg = 'Expected to be non empty object') => {
    assertObject(val, msg);
    assert(Object.keys(val).length > 0, msg);
};
const isOneOf = (collection, val) => {
    if (isArray(collection)) {
        return collection.includes(val);
    }
    if (isObject(collection)) {
        return Object.values(collection).includes(val);
    }
    return false;
};
const assertOneOf = (collection, val, msg = 'Expected to be one of the collection elements') => {
    assert(isOneOf(collection, val), msg);
};
const isFunction = (val) => typeof val === 'function' && !/^class\s/.test(Function.prototype.toString.call(val));
const isFunctionConstructor = (val) => typeof val === 'function' && /^class\s/.test(Function.prototype.toString.call(val));
const assertFunction = (val, msg = 'Expected to be a function') => {
    assert(isFunction(val), msg);
};
const assertClass = (val, msg = 'Expected to be a class') => {
    assert(isFunctionConstructor(val), msg);
};
const isNumber = (val) => typeof val === 'number' && !isNaN(val);
const assertNumber = (val, msg = 'Expected to be a number') => {
    assert(isNumber(val), msg);
};

var check = /*#__PURE__*/Object.freeze({
  __proto__: null,
  assert: assert,
  isDefined: isDefined,
  assertDefined: assertDefined,
  isString: isString,
  assertString: assertString,
  assertNonEmptyString: assertNonEmptyString,
  isArray: isArray,
  isNonEmptyArray: isNonEmptyArray,
  assertArray: assertArray,
  asserNotEmptytArray: asserNotEmptytArray,
  isObject: isObject,
  assertObject: assertObject,
  assertNonEmptyObject: assertNonEmptyObject,
  isOneOf: isOneOf,
  assertOneOf: assertOneOf,
  isFunction: isFunction,
  isFunctionConstructor: isFunctionConstructor,
  assertFunction: assertFunction,
  assertClass: assertClass,
  isNumber: isNumber,
  assertNumber: assertNumber
});

const NOT_VALID_PROTOCOL = 'Not a valid protocol';
const NOT_VALID_ADDRESS = 'Address must be of type object';
const NOT_VALID_HOST = 'Not a valid host';
const NOT_VALID_PATH = 'Not a valid path';
const NOT_VALID_PORT = 'Not a valid port';
const ASYNC_MODEL_TYPES = {
    REQUEST_RESPONSE: 'requestResponse',
    REQUEST_STREAM: 'requestStream',
};
const SERVICE_NAME_NOT_PROVIDED = 'MS0020 - Invalid format, definition must contain valid serviceName';
const DEFINITION_MISSING_METHODS = 'MS0021 - Invalid format, definition must contain valid methods';
const INVALID_METHODS = 'MS0022 - Invalid format, definition must contain valid methods';
const getServiceNameInvalid = (serviceName) => `MS0023 - Invalid format, serviceName must be not empty string but received type ${typeof serviceName}`;
const getIncorrectMethodValueError = (qualifier) => `Method value for ${qualifier} definition should be non empty object`;
const getAsynModelNotProvidedError = (qualifier) => `Async model is not provided in service definition for ${qualifier}`;
const getInvalidAsyncModelError = (qualifier) => `Invalid async model in service definition for ${qualifier}`;

var constants = /*#__PURE__*/Object.freeze({
  __proto__: null,
  NOT_VALID_PROTOCOL: NOT_VALID_PROTOCOL,
  NOT_VALID_ADDRESS: NOT_VALID_ADDRESS,
  NOT_VALID_HOST: NOT_VALID_HOST,
  NOT_VALID_PATH: NOT_VALID_PATH,
  NOT_VALID_PORT: NOT_VALID_PORT,
  ASYNC_MODEL_TYPES: ASYNC_MODEL_TYPES,
  SERVICE_NAME_NOT_PROVIDED: SERVICE_NAME_NOT_PROVIDED,
  DEFINITION_MISSING_METHODS: DEFINITION_MISSING_METHODS,
  INVALID_METHODS: INVALID_METHODS,
  getServiceNameInvalid: getServiceNameInvalid,
  getIncorrectMethodValueError: getIncorrectMethodValueError,
  getAsynModelNotProvidedError: getAsynModelNotProvidedError,
  getInvalidAsyncModelError: getInvalidAsyncModelError
});

const validateAddress = (address, isOptional = true) => {
    if (isOptional && typeof address === 'undefined') {
        return true;
    }
    assertNonEmptyObject(address, NOT_VALID_ADDRESS);
    const { host, path, protocol } = address;
    let { port } = address;
    port = isString(port) ? Number(port) : port;
    assertString(host, NOT_VALID_HOST);
    assertString(path, NOT_VALID_PATH);
    assertNumber(port, NOT_VALID_PORT);
    assertString(protocol, NOT_VALID_PROTOCOL);
    assert(isOneOf(['pm', 'ws', 'wss', 'tcp'], protocol), NOT_VALID_PROTOCOL);
    return true;
};
/**
 * address is <protocol>://<host>:<port>/<path>
 */
const getFullAddress = (address) => {
    validateAddress(address, false);
    const { host, path, port, protocol } = address;
    return `${protocol}://${host}:${port}/${path}`;
};
const getAddress = (address) => {
    const newAddress = {};
    address = buildAddress({ key: 'protocol', optionalValue: 'pm', delimiter: '://', str: address, newAddress });
    address = buildAddress({ key: 'host', optionalValue: 'defaultHost', delimiter: ':', str: address, newAddress });
    address = buildAddress({ key: 'port', optionalValue: 8080, delimiter: '/', str: address, newAddress });
    newAddress.path = address;
    return newAddress;
};
const buildAddress = ({ key, optionalValue, delimiter, newAddress, str, }) => {
    let [v1, rest] = str.split(delimiter);
    if (!rest) {
        rest = v1;
        v1 = optionalValue;
    }
    newAddress[key] = v1;
    return rest;
};

const isNodejs = () => {
    try {
        // common api for main threat or worker in the browser
        return !navigator;
    }
    catch (e) {
        return false;
    }
};

const workersMap = {};
const registeredIframes = {};
const iframes = [];
/**
 * check from which iframe the event arrived,
 * @param ev
 */
const registerIframe = (ev) => {
    iframes.some((iframe) => {
        if (ev.source === iframe.contentWindow) {
            registeredIframes[ev.data.detail.whoAmI || ev.data.detail.origin] = iframe;
        }
        return ev.source === iframe.contentWindow;
    });
};
const initialize = () => {
    if (!isNodejs()) {
        // @ts-ignore
        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
            console.warn(`Don't use this on webworkers, only on the main thread`);
        }
        else {
            addEventListener('message', (ev) => {
                if (ev && ev.data && !ev.data.workerId) {
                    ev.data.type === 'ConnectIframe' && registerIframe(ev);
                    const detail = ev.data.detail;
                    if (detail) {
                        ev.data.workerId = 1;
                        const propogateTo = workersMap[detail.to] || workersMap[detail.address]; // discoveryEvents || rsocketEvents
                        if (propogateTo) {
                            // @ts-ignore
                            propogateTo.postMessage(ev.data, ev.ports);
                        }
                        const iframe = registeredIframes[detail.to] || registeredIframes[detail.address];
                        if (iframe) {
                            iframe.contentWindow.postMessage(ev.data, '*', ev.ports);
                        }
                    }
                }
            });
        }
    }
};
function workerEventHandler(ev) {
    if (ev.data && ev.data.detail && ev.data.type) {
        const detail = ev.data.detail;
        if (!ev.data.workerId) {
            ev.data.workerId = 1;
            if (ev.data.type === 'ConnectWorkerEvent') {
                if (detail.whoAmI) {
                    // @ts-ignore
                    workersMap[detail.whoAmI] = this;
                }
            }
            else {
                const propogateTo = workersMap[detail.to] || workersMap[detail.address]; // discoveryEvents || rsocketEvents
                if (propogateTo) {
                    // @ts-ignore
                    propogateTo.postMessage(ev.data, ev.ports);
                }
                else {
                    // @ts-ignore
                    postMessage(ev.data, '*', ev.ports);
                }
            }
        }
    }
}
const addWorker = (worker) => {
    worker.addEventListener('message', workerEventHandler.bind(worker));
};
const removeWorker = (worker) => {
    worker.removeEventListener('message', workerEventHandler.bind(worker));
};
const addIframe = (iframe) => {
    iframes.push(iframe);
};

const colorsMap = {};
const getRandomColor = () => {
    const letters = '0123456789ABCDEF';
    let color = '#';
    for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
};
const saveToLogs = (identifier, msg, extra, debug, type = 'log') => {
    if (!colorsMap[identifier]) {
        colorsMap[identifier] = getRandomColor();
    }
    // tslint:disable
    if (debug) {
        const logColor = `color:${colorsMap[identifier]}`;
        extra && console[type](`%c******** address: ${identifier}********`, logColor);
        console[type](msg);
        extra &&
            Object.keys(extra).forEach((key) => {
                if (Array.isArray(extra[key])) {
                    Object.values(extra[key]).forEach((props) => {
                        console[type](`${key}: ${JSON.stringify(props.qualifier || props, null, 2)}`);
                    });
                }
                else {
                    console[type](`${key}: ${JSON.stringify(extra[key], null, 2)}`);
                }
            });
    }
    // tslint:enable
};

const getQualifier = ({ serviceName, methodName }) => `${serviceName}/${methodName}`;

const validateServiceDefinition = (definition) => {
    assertNonEmptyObject(definition);
    const { serviceName, methods } = definition;
    assertDefined(serviceName, SERVICE_NAME_NOT_PROVIDED);
    assertNonEmptyString(serviceName, getServiceNameInvalid(serviceName));
    assertDefined(methods, DEFINITION_MISSING_METHODS);
    assertNonEmptyObject(methods, INVALID_METHODS);
    Object.keys(methods).forEach((methodName) => {
        assertNonEmptyString(methodName);
        const qualifier = getQualifier({ serviceName, methodName });
        validateAsyncModel(qualifier, methods[methodName]);
    });
};
const validateAsyncModel = (qualifier, val) => {
    assertNonEmptyObject(val, getIncorrectMethodValueError(qualifier));
    const { asyncModel } = val;
    assertDefined(asyncModel, getAsynModelNotProvidedError(qualifier));
    assertOneOf(ASYNC_MODEL_TYPES, asyncModel, getInvalidAsyncModelError(qualifier));
};

const applyPostMessagePolyfill = () => {
    const addEventListenerQueue = {};
    // @ts-ignore
    global.postMessage = (message, targetOrigin, transfer) => {
        const onMessageQueue = addEventListenerQueue.message || [];
        onMessageQueue.forEach((fn) => {
            fn({
                ports: transfer,
                data: message,
                type: 'message',
            });
        });
    };
    const globaladdEventListener = addEventListener;
    // @ts-ignore
    addEventListener = (type, cb) => {
        if (type === 'message') {
            const eventQueueByType = [...(addEventListenerQueue[type] || []), cb];
            addEventListenerQueue[type] = eventQueueByType;
        }
        else {
            globaladdEventListener(type, cb);
        }
    };
};

// polyfill MessagePort and MessageChannel
class MessagePortPolyfill {
    constructor(whoami) {
        this.onmessage = null;
        this.onmessageerror = null;
        this.otherPort = null;
        this.onmessageListeners = [];
        this.queue = [];
        this.otherSideStart = false;
        this.whoami = whoami;
    }
    dispatchEvent(event) {
        if (this.onmessage) {
            this.onmessage(event);
        }
        this.onmessageListeners.forEach((listener) => listener(event));
        return true;
    }
    postMessage(message, ports) {
        const event = {
            ports,
            data: message,
        };
        if (!this.otherPort) {
            return;
        }
        if (this.otherSideStart) {
            this.otherPort.dispatchEvent(event);
        }
        else {
            this.queue.push(event);
        }
    }
    addEventListener(type, listener) {
        if (type !== 'message') {
            return;
        }
        if (typeof listener !== 'function' || this.onmessageListeners.indexOf(listener) !== -1) {
            return;
        }
        this.onmessageListeners.push(listener);
    }
    removeEventListener(type, listener) {
        if (type !== 'message') {
            return;
        }
        const index = this.onmessageListeners.indexOf(listener);
        if (index === -1) {
            return;
        }
        this.onmessageListeners.splice(index, 1);
    }
    start() {
        setTimeout(() => this.otherPort && this.otherPort.startSending.apply(this.otherPort, []), 0);
    }
    close() {
        setTimeout(() => this.otherPort && this.otherPort.stopSending.apply(this.otherPort, []), 0);
    }
    startSending() {
        this.otherSideStart = true;
        this.queue.forEach((event) => this.otherPort && this.otherPort.dispatchEvent(event));
    }
    stopSending() {
        this.otherSideStart = false;
        this.queue.length = 0;
    }
}
// tslint:disable-next-line
class MessageChannelPolyfill {
    constructor() {
        this.port1 = new MessagePortPolyfill('client');
        this.port2 = new MessagePortPolyfill('server');
        this.port1.otherPort = this.port2;
        this.port2.otherPort = this.port1;
    }
}
const globalObj = typeof window !== 'undefined' && window.Math === Math
    ? window
    : typeof self !== 'undefined' && self.Math === Math
        ? self
        : Function('return this')();
function applyMessageChannelPolyfill() {
    globalObj.MessagePort = MessagePortPolyfill;
    globalObj.MessageChannel = MessageChannelPolyfill;
}
if (!globalObj.MessagePort || !globalObj.MessageChannel) {
    applyMessageChannelPolyfill();
}

const workers = !isNodejs() ? { addWorker, removeWorker, initialize, addIframe } : {};
const mockMessageChannel = () => {
    applyPostMessagePolyfill();
    applyMessageChannelPolyfill();
};

exports.check = check;
exports.constants = constants;
exports.getAddress = getAddress;
exports.getFullAddress = getFullAddress;
exports.getQualifier = getQualifier;
exports.isNodejs = isNodejs;
exports.mockMessageChannel = mockMessageChannel;
exports.saveToLogs = saveToLogs;
exports.validateAddress = validateAddress;
exports.validateServiceDefinition = validateServiceDefinition;
exports.workers = workers;
